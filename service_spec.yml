service_name: some-service

# Version lock the platform dependency.
# Use semantic versioning.
porter_version: v0.0.1

# Optional and not advertised. Some of our services still require this because
# they have CloudFormation customizations that shouldn't live in porter.
stack_definition_path: .porter/stack_definition

# Slack channel where CI/CD pipeline notifications are sent.
slack:
  team: "team1"
  username: "user1"
  channel: "channel1"

build:
  jenkins:
    rollback: false
    params:
    - name: "param1"
      # Allowed values string/boolean
      type: "string"
      # Default value is optional.
      default_value: "value1"
    - name: "param2"
      type: boolean


environments:
# name is an opaque string but must match /^[0-9a-zA-Z]+$/
# The dev environment describes a developer environment with a single
# container and minimal resource requirements.

# Note: The environments get deployed in the order specified in this file.
- name: dev1    # Note: There can be multiple test environment of DEV type, e.g. "dev, qa1, qa2 etc".
  # Optional in the simplest case with defaults.
  # The default is a "inet" type service with a single EXPOSEd port and a health
  # check of `GET /health HTTP/1.1`

  # "type" is one of DEV/STAGE/PROD. Based on this appropriate Mesos cluster may get selected.
  type: DEV
  containers:
  # see footnote [1]
  - id: some_container
    # required.
    # [inet|worker|cron]
    topology: inet

    # optional. Required if more than one container is defined
    dockerfile_path: Dockerfile

    # optional.
    # override CMD. e.g., `docker run image:latest <docker_run_cmd>`
    docker_run_cmd: --opt foo

    # optional. Required if EXPOSEing multiple ports
    inet_port: 3000

    # optional.
    health_check:
      method: GET
      path: /health

    # The following two options will be used to select the EC2 instance type in
    # porter:

    # [1]
    cpus: 1

    # MB [1]
    mem: 100

    # Create a single instance of this container [1]
    instances: 1

  regions:
  # Our developers are based in Seattle, in this example
  - name: us-west-2
    # AZs are heterogeneous.
    # Some don't work with others and certain instance types can only deploy to
    # certain AZs. For a custom VPC (i.e. not EC2-Classic or Default VPC) we
    # additionally need the subnet ID
    availability_zones:
    - {name: us-west-2a, subnet_id: ''}

    # This is the role ARN porter needs to do
    # http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html
    role_arn: arn:aws:iam::123456789012:role/some-service-deployment

    # Not defined for a developer environment
    # elb:

    # The name of the SSH key in the region that will be used to login to the
    # instance
    key_pair_name: some-developer-key

    # How is the service distributed?
    # S3 is the only option porter currently supports
    service_distribution:
      # [s3|docker_registry]
      type: s3
      # If type is s3, prefix its options with s3_
      # The bucket into which the service payload will be uploaded by porter
      # in GoCD, and then downloaded by porter on an EC2 instance
      s3_bucket: some-service-builds-us-west-2

      # If type is docker_registry, prefix its options with docker_registry_
      # docker_registry_url: http://somedomain.com
  jenkins:
    rollback: false
    params:
    - name: "param2"
      type: "string"
    - name: "param3"
      type: boolean
      default_value: true

# prod is a more complex production environment
- name: prod
  type: PROD  # One of DEV/STAGE/PROD

  containers:
  - id: some_container
    topology: inet
    dockerfile_path: Dockerfile
    inet_port: 3000
    health_check:
      method: GET
      path: /health
    cpus: 4
    mem: 400
    instances: 10
  # The prod environment additionally defines a worker variant of the service's
  # codebase to be run
  - id: some_worker_container
    topology: worker
    dockerfile_path: Dockerfile.worker
    cpus: 8
    mem: 1024
    instances: 4
  # And lastly a simple cron job
  - id: some_cron_container
    topology: cron
    dockerfile_path: Dockerfile.cron
    cpus: 1
    mem: 100
    instances: 1

  regions:
  - name: us-west-2
    availability_zones:
    - {name: us-west-2a, subnet_id: ''}
    - {name: us-west-2b, subnet_id: ''}
    - {name: us-west-2c, subnet_id: ''}

    role_arn: arn:aws:iam::123456789012:role/some-service-deployment

    elb:
    - {name: some-service-production, tag: prod}

    key_pair_name: some-production-key

    service_distribution:
      type: s3
      s3_bucket: some-service-builds-us-west-2

  - name: us-east-1
    availability_zones:
    - {name: us-east-1a, subnet_id: ''}
    - {name: us-east-1b, subnet_id: ''}
    - {name: us-east-1c, subnet_id: ''}

    role_arn: arn:aws:iam::123456789012:role/some-service-deployment

    elb:
    - {name: some-service-production, tag: prod}

    key_pair_name: some-production-key

    service_distribution:
      type: s3
      s3_bucket: some-service-builds-us-east-1

  jenkins:
    rollback: false
    params:
    - name: "param3"
      type: "string"
      default_value: "value3"

# [1] matches Marathon app definition https://mesosphere.github.io/marathon/docs/application-basics.html
